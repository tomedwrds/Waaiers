import { useEffect, useState } from 'react';
import RouteWindMap from './RouteWindMap';
import IntrestSegmentContainer from '../segments of intrest/IntrestSegmentContainer';
import { useLocation, useNavigate } from 'react-router-dom';
import generateMapData from './generateMapData';
import getUserAccessStatus from '../upload route/getUserData';
import supabase from '../supabase/supabase';



import './MainMapPage.css'

import MapProfile from './MapProfile';
import Loading from './Loading';
import getIntrestRace from './getIntrestRace';


const MainMapPage = () => {
    
  

    //Create the postion and segments state hook
    const [positions,setPositions] = useState(null);
    const [points,setPoints] = useState(null);
    const [segments,setSegments] = useState(null);
    const [routeData, setRouteData] = useState(null);
    const [selectedDataPoint,setSelectedDatapoint] = useState([0,0])

    //Create the segemtn store hook
    const [segmentsSort,setSegmentSort] = useState("stars")

    //Create the wind direction hook
    const [windDir,setWindDir] = useState("all")

    //Set up the map paramters for the generation of Segments
    const [segmentParameters,setSegmentParameters] = useState({
        minWindSpeed: 10,
        maxWindSpeed: 30,
        minSegmentLength: 1000,
        maxSegmentLength: 10000,
        windAngleGolden: 75,
        windAngleZone: 30
    })
    //Get the data passed through react router
    const {state} = useLocation()


    //Navigation hooks
    const navigate = useNavigate();

    
    async function getRoutePointData(i,routeData)
    {
        //Queries and returns 1000 data points
        //The get points weatehr is a custom made postgresql function it exists on supabase
        //The function is
        /*
        CREATE OR REPLACE FUNCTION get_points_weather(route int8 default 0)
            RETURNS TABLE (
            point_lat float8,
            point_lon float8,
            point_dir float4,
            point_distance_start float4,
            point_distance_end float4,
            weather_winddir float8,
            weather_windspeed float4,
            weather_windgust float4
            )
            AS $$
            BEGIN
            RETURN QUERY 
            SELECT "Points".point_lat, "Points".point_lon, "Points".point_dir, "Points".point_distance_start, "Points".point_distance_end,  "Weather".weather_winddir,"Weather".weather_windspeed, "Weather".weather_windgust
            FROM "Points" INNER JOIN "Weather" on "Weather".id = "Points".weather_id
            WHERE "Points".route_id = route;
            END;
            $$ LANGUAGE plpgsql;
        */

        const startPoint = i*1000;
        const endPoint  = ((i+1)*1000)-1
        const {data} = await supabase.rpc('get_points_weather',{route: routeData.id}).range(startPoint,endPoint)
        return data;
    }

    async function fetchRouteData(route_id)
    {
        //Query supabase to get route data and store it
        const {data} = await supabase.from('Routes').select('*').eq('id',route_id);
        const route_data = data[0];
        
        
        //Next we must get the point data for that route due to api restrictions
        //Only 1000 data points can be retrieved from the database in a single api call to supabase
        //Therefore the query is repeated until until all data is retreived
        let pointData = []
        do{
            //Function is assync hence await keyword is needed. '...' is used to destructure the array
            pointData.push(...(await (getRoutePointData(Math.floor(pointData.length/1000),route_data))))
        } while(pointData.length % 1000 == 0 && pointData.length != 0)

        return({point_data: pointData,route_data: route_data})
      
    }

    async function intalizeMap()
    {
        //Check if the route is one generated by a user in which case we need to get route/ point data from router or is one from DB at which point we need to call DB
        let point_data = []
        let route_data = [];

        if(state != null)
        {
            point_data = state.pointData;
            route_data = state.routeData;
        }
        else
        {
            //When the user loads a page the URL stores information about what route to load. However the home page is also the root path so therefore the user can end up on this page with junk in their url.
            //Thus it must be determined wether the race in the pages url is valid by checking it against a list of urls

            //First set the rouute id value to default value of 0
            let race_id = 0;
            //The route id is stored after the race therefore it makes the 3rd part of url. ie waaiers.xyz/race/10
            const raceIDURL = window.location.pathname.split('/')[2];
            //The first check is if raceId is defined. Some urls may be invalid and of form waaiers.xyz/asfaf and therefore their is no 3rd part.
            if(raceIDURL != undefined)
            {
                //Now that we know the race ID is defined we must check if it is a valid id ie the route should actaully be viewable
                //This is done by getting all the route ids and comparing them with this value to see if its in the list

                //Due to limitation in supabase at this point in time we have to query for both route visible value 1 and 2 as they are both valid and cant be queries at same time.
                //Route visible 1 means route is displayed but locked but 2 means route is dispalyed
                const routeQueryLocked = await supabase.from('Routes').select('*').eq('route_visible',1);
                const routeQueryDisplayed = await supabase.from('Routes').select('*').eq('route_visible',2);
                
                const validRoutesLocked = routeQueryLocked.data;
                const validRoutesDisplayed = routeQueryDisplayed.data;
                
                //Check if the route in url is in this valid list of locked routes or displayed routes
                let isRouteLocked = false;
                validRoutesLocked.map(((item)=>{if(item.id==raceIDURL) isRouteLocked = item.route_name;}))

                let isRouteDisplayed = false;
                validRoutesDisplayed.map(((item)=>{if(item.id==raceIDURL) isRouteDisplayed = true;}))
                
                if(isRouteDisplayed)
                {
                    //If this case we want to see the id to display to that of url
                    race_id = raceIDURL
                }
                else if (isRouteLocked)
                {
                    //In case it is locked we need to spoof the route data so it renders the locked page
                    setRouteData({route_name:isRouteLocked,route_visible:1})
                }
                else
                {
                    
                    //If the race id in the url is not valid we wont to navigte to the homepage
                    navigate('/');
                   
                }
            }
            else if(window.location.pathname == '/')
            {
                //In this case we are on home page and want load the relavent race_id
                race_id=await getIntrestRace();
              
            }   
            else
            {
                navigate('/');
            }

            //Check that race id is no longer default value
            if(race_id != 0)
            {
                 //Finally get the data for that route
                const database_data = await fetchRouteData(race_id);
                    
                
                point_data = database_data.point_data
                route_data = database_data.route_data
            }

           
        }


        //Check to make sure these functions dont run if invalid URL
        if(point_data.length != 0 && route_data.length != 0)
        {
            //Store the point data for use in route cenering
            setPoints(point_data)

            
            //Fetches the weather data on page load
            generateMapData(point_data,setPositions,setSegments,segmentParameters);

            //Also gets the route data
            setRouteData(route_data);
        }
        
    }

    useEffect(() => {
        intalizeMap()
    }, [])

    
   
    //The page can redner in one of 3 states the first is a locked dispaly screen caused when the race is more than 3 days away
    // The second is the normal map and the third is a loading page
    

    
    if(routeData != null)
    {
        if(routeData.route_visible == 1)
        {
            return(
                <div className = "body-locked">  
                    <div className='mainMapHeader'>
                        <h2>{routeData.route_name}</h2>
                    </div>
                    <div style={{marginTop:'120px',marginBottom:'120px'}}>  
                    <h2 style={{marginBottom:'0px'}}>Check back Later</h2>
                    <p style={{marginTop:'5px',color:'grey'}}>Waaiers wind maps release seven days before a race starts</p>
                </div>
                </div>

            )
        }
        else{
            return(
                <div className = "body">  
                    <div className='mainMapHeader'>
                        <h2>{routeData.route_name}</h2>
                            <div className='segmentIntrestSort'>
                                <p>Wind Direction:</p>
                                <select className='segmentIntrestSelect' onChange={(e)=>setWindDir(e.target.value)}>
                                    <option value="all">All</option>
                                    <option value="cross">Cross</option>
                                    <option value="head">Head</option>
                                    <option value="tail">Tail</option>
                                </select>
                            </div>
                    </div>
                   
                    <RouteWindMap pointData = {points} positionData = {positions} routeData = {routeData} windDirection = {windDir} selectedDataPoint ={selectedDataPoint} />
                    
        
                    <div className='segmentIntrestHeader'>
                        <h2>Route Wind Profile</h2>  
                        
                    </div>
        
                    <MapProfile pointData = {positions} setSelectedDatapoint = {setSelectedDatapoint}/>
                   
                    <div className='segmentIntrestHeader'>
                        <h2>Segments of Intrest</h2>
                        <div className='segmentIntrestSort'>
                            <p>Sort by:</p>
                            <select className='segmentIntrestSelect' onChange={(e)=>setSegmentSort(e.target.value)}>
                                <option value="stars">Stars</option>
                                <option value="order">Order</option>
                            </select>
                        </div>
                        
                    </div>
        
        
                    
                    <IntrestSegmentContainer data = {segments} sortOrder = {segmentsSort} windDirection = {windDir} />
                </div>
                )
            
        }
        
    }
    else{
        return(
            <Loading/>
        )
    }
}


export default MainMapPage